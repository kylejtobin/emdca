---
description: EMDCA architectural rules for AI-assisted development
globs: ["**/*.py"]
alwaysApply: true
---

## ⚖️ The 10 Mandates

1.  **Construction:** Use Value Objects & Pure Factories. Parse, don't validate. ([Pattern 01](spec/patterns/01-factory-construction.md))
2.  **State:** Use Sum Types (Discriminated Unions). Make invalid states unrepresentable. ([Pattern 02](spec/patterns/02-state-sum-types.md))
3.  **Control Flow:** Use Railway Oriented Programming. No Exceptions for logic. ([Pattern 03](spec/patterns/03-railway-control-flow.md))
4.  **Execution:** Return Intents as Contracts. Complete specification of side effects and outcomes. ([Pattern 04](spec/patterns/04-execution-intent.md))
5.  **Configuration:** Treat EnvVars as Foreign Reality. Translate to pure AppConfig. ([Pattern 05](spec/patterns/05-config-injection.md))
6.  **Storage:** Treat DB as Foreign Reality. Translate to pure Domain Objects. ([Pattern 06](spec/patterns/06-storage-foreign-reality.md))
7.  **Translation:** Use Foreign Models. Declarative mapping of External Reality to Internal Truth. ([Pattern 07](spec/patterns/07-acl-translation.md))
8.  **Coordination:** Use a Dumb Orchestrator. The loop only moves data; it never thinks. ([Pattern 08](spec/patterns/08-orchestrator-loop.md))
9.  **Workflow:** Model Process as a State Machine. The Domain drives the next step. ([Pattern 09](spec/patterns/09-workflow-state-machine.md))
10. **Infrastructure:** Model Capability as Data. Topology is configuration, not code. ([Pattern 10](spec/patterns/10-infrastructure-capability-as-data.md))


## Building Blocks (Use These Types)
- Smart Enums: `class Status(StrEnum)` with `@property` methods
- Value Objects: `Annotated[str, AfterValidator(...)]`
- Aggregates: Frozen Pydantic models with decision methods returning Intents
- Commands: Inbound ADTs (what the caller wants)
- Intents: Outbound ADTs (what should happen)
- Events: Domain facts (what happened)
- Results: `Success | Failure` discriminated unions
- Ports: `typing.Protocol` for external dependencies

## Implementation Order
1. Smart enums and value objects
2. Aggregates (pure decision logic)
3. Commands / Intents / Events / Results
4. Ports (protocols)
5. Services (orchestration only)
6. Adapters (thin I/O)

## LLM Rules (When Generating Code)
- Add new variants, never boolean flags
- Dispatch on types via match/case, never `if kind == ...`
- Domain functions are pure: no I/O, no await
- All outcomes are discriminated unions, never exceptions
- Intents contain ALL data needed for execution

## Prohibited
- `raise` for domain logic (use Result types)
- `Optional` fields for mutually exclusive states (use Sum Types)
- Business logic in services or adapters
- `os.environ` access outside the composition root
- Mutable domain models

## Reference
- Full spec: spec/arch.md
- Patterns: spec/patterns/01-10
- Examples: spec/src/
- Agent translation: spec/agentic.md
